{"version":3,"file":"next-passport.cjs.production.min.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/errors.ts","../src/auth-utils.ts","../src/middleware.ts","../src/secure-proxy-middleware.ts","../src/utils/index.ts","../src/passportAuth.ts","../src/constants.ts","../src/session.ts"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","export class AuthenticationError extends Error {\n  name = 'AuthenticationError';\n  statusCode = 401;\n  constructor(message = 'You must be logged in to access this') {\n    super(message);\n  }\n  get _clearStack() {\n    return true;\n  }\n}\n\nexport class CSRFTokenMismatchError extends Error {\n  name = 'CSRFTokenMismatchError';\n  statusCode = 401;\n  get _clearStack() {\n    return true;\n  }\n}\n\nexport class AuthorizationError extends Error {\n  name = 'AuthorizationError';\n  statusCode = 403;\n  constructor(message = 'You are not authorized to access this') {\n    super(message);\n  }\n  get _clearStack() {\n    return true;\n  }\n}\n\nexport class NotFoundError extends Error {\n  name = 'NotFoundError';\n  statusCode = 404;\n  constructor(message = 'This could not be found') {\n    super(message);\n  }\n  get _clearStack() {\n    return true;\n  }\n}\n","import * as crypto from 'crypto';\nimport { nanoid } from 'nanoid';\nimport SecurePasswordLib from 'secure-password';\nimport { AuthenticationError } from './errors';\n\nexport const hash256 = (input: string = '') =>\n  crypto.createHash('sha256').update(input).digest('hex');\n\nexport const generateToken = (numberOfCharacters: number = 32) =>\n  nanoid(numberOfCharacters);\n\nconst SP = () => new SecurePasswordLib();\n\nexport const SecurePassword = {\n  ...SecurePasswordLib,\n  async hash(password: string | null | undefined) {\n    if (!password) {\n      throw new AuthenticationError();\n    }\n    const hashedBuffer = await SP().hash(Buffer.from(password));\n    return hashedBuffer.toString('base64');\n  },\n  async verify(\n    hashedPassword: string | null | undefined,\n    password: string | null | undefined\n  ) {\n    if (!hashedPassword || !password) {\n      throw new AuthenticationError();\n    }\n    try {\n      const result = await SP().verify(\n        Buffer.from(password),\n        Buffer.from(hashedPassword, 'base64')\n      );\n      // Return result for valid results.\n      switch (result) {\n        case SecurePassword.VALID:\n        case SecurePassword.VALID_NEEDS_REHASH:\n          return result;\n      }\n      // For everything else throw AuthenticationError\n      throw new AuthenticationError();\n    } catch (error) {\n      // Could be error like failed to hash password\n      throw new AuthenticationError();\n    }\n  },\n};\n\nexport const hashPassword = async (password: string) => {\n  const hashedBuffer = await SP().hash(Buffer.from(password));\n  return hashedBuffer.toString('base64');\n};\n\nexport const verifyPassword = async (\n  hashedPassword: string,\n  password: string\n) => {\n  try {\n    return await SP().verify(\n      Buffer.from(password),\n      Buffer.from(hashedPassword, 'base64')\n    );\n  } catch (error) {\n    console.error(error);\n    return false;\n  }\n};\n\nexport const authenticateUser = async (\n  prisma: any,\n  email: string,\n  password: string\n) => {\n  const user = await prisma.user.findFirst({\n    where: { email: email.toLowerCase() },\n  });\n\n  if (!user || !user.hashedPassword) throw new AuthenticationError();\n\n  switch (await verifyPassword(user.hashedPassword, password)) {\n    case SecurePassword.VALID:\n      break;\n    case SecurePassword.VALID_NEEDS_REHASH:\n      // Upgrade hashed password with a more secure hash\n      const improvedHash = await hashPassword(password);\n      await prisma.user.update({\n        where: { id: user.id },\n        data: { hashedPassword: improvedHash },\n      });\n      break;\n    default:\n      throw new AuthenticationError();\n  }\n\n  const { hashedPassword, ...rest } = user;\n  return rest;\n};\n","/* eslint-disable es5/no-es6-methods  -- file only used on the server */\nimport { IncomingMessage, ServerResponse } from 'http';\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport {\n  ConnectMiddleware,\n  EnhancedResolver,\n  Middleware,\n  MiddlewareNext,\n  MiddlewareRequest,\n  MiddlewareResponse,\n} from './types';\n\nexport interface DefaultCtx {}\nexport interface Ctx extends DefaultCtx {}\n\nexport function getAllMiddlewareForModule<TInput, TResult>(\n  resolverModule: EnhancedResolver<TInput, TResult>\n) {\n  const middleware: Middleware[] = [];\n\n  if (resolverModule.middleware) {\n    if (!Array.isArray(resolverModule.middleware)) {\n      throw new Error(\n        `'middleware' exported from ${resolverModule._meta.name} must be an array`\n      );\n    }\n    middleware.push(...resolverModule.middleware);\n  }\n  return middleware;\n}\n\nexport async function handleRequestWithMiddleware(\n  req: NextApiRequest | IncomingMessage,\n  res: NextApiResponse | ServerResponse,\n  middleware: Middleware | Middleware[],\n  {\n    throwOnError = true,\n    stackPrintOnError = true,\n  }: {\n    throwOnError?: boolean;\n    stackPrintOnError?: boolean;\n  } = {}\n) {\n  if (!(res as MiddlewareResponse).blitzCtx) {\n    (res as MiddlewareResponse).blitzCtx = {};\n  }\n  if (!(res as any)._blitz) {\n    (res as any)._blitz = {};\n  }\n\n  let handler: Middleware;\n  if (Array.isArray(middleware)) {\n    handler = compose(middleware);\n  } else {\n    handler = middleware;\n  }\n\n  try {\n    await handler(\n      req as MiddlewareRequest,\n      res as MiddlewareResponse,\n      error => {\n        if (error) {\n          throw error;\n        }\n      }\n    );\n  } catch (error) {\n    if (req.method === 'GET') {\n      // This GET method check is so we don't .end() the request for SSR requests\n      console.log('Error while processing the request');\n    } else if (res.writableFinished) {\n      console.log(\n        'Error occured in middleware after the response was already sent to the browser'\n      );\n    } else {\n      res.statusCode =\n        (error as any).statusCode || (error as any).status || 500;\n      res.end(error.message || res.statusCode.toString());\n      console.log('Error while processing the request');\n    }\n    if (error._clearStack) {\n      delete error.stack;\n    }\n    if (stackPrintOnError) {\n      console.log(error);\n    } else {\n      console.log(error, true, false, false);\n    }\n\n    if (throwOnError) throw error;\n  }\n}\n\n// -------------------------------------------------------------------------------\n// This takes an array of middleware and composes them into a single middleware fn\n// This is what makes `next()` and `await next()` work\n// -------------------------------------------------------------------------------\nexport function compose(middleware: Middleware[]) {\n  if (!Array.isArray(middleware)) {\n    throw new TypeError('Middleware stack must be an array!');\n  }\n\n  for (const handler of middleware) {\n    if (typeof handler !== 'function') {\n      throw new TypeError('Middleware must be composed of functions!');\n    }\n  }\n\n  // Return a single middleware function that composes everything passed in\n  return function(req, res, next): Promise<any> {\n    // last called middleware #\n    let index = -1;\n\n    function dispatch(i: number, error?: any): Promise<void> {\n      if (error) {\n        return Promise.reject(error);\n      }\n\n      if (i <= index) throw new Error('next() called multiple times');\n      index = i;\n\n      let handler = middleware[i];\n      if (!handler) {\n        return Promise.resolve();\n      }\n\n      try {\n        return Promise.resolve(handler(req, res, dispatch.bind(null, i + 1)));\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n\n    // const result = await dispatch(0)\n    // return next(result as any)\n    return dispatch(0).then(next as any);\n  } as Middleware;\n}\n\n/**\n * If the middleware function doesn't declare receiving the `next` callback\n * assume that it's synchronous and invoke `next` ourselves\n */\nfunction noCallbackHandler(\n  req: MiddlewareRequest,\n  res: MiddlewareResponse,\n  next: MiddlewareNext,\n  middleware: ConnectMiddleware\n) {\n  // Cast to any to call with two arguments for connect compatibility\n  (middleware as any)(req, res);\n  return next();\n}\n\n/**\n * The middleware function does include the `next` callback so only resolve\n * the Promise when it's called. If it's never called, the middleware stack\n * completion will stall\n */\nfunction withCallbackHandler(\n  req: MiddlewareRequest,\n  res: MiddlewareResponse,\n  next: MiddlewareNext,\n  middleware: ConnectMiddleware\n) {\n  return new Promise((resolve, reject) => {\n    // Rule doesn't matter since we are inside new Promise()\n    //eslint-disable-next-line @typescript-eslint/no-floating-promises\n    middleware(req, res, err => {\n      if (err) reject(err);\n      else resolve(next());\n    });\n  });\n}\n\n/**\n * Returns a Blitz middleware function that varies its async logic based on if the\n * given middleware function declares at least 3 parameters, i.e. includes\n * the `next` callback function\n */\nexport function connectMiddleware(middleware: ConnectMiddleware): Middleware {\n  const handler =\n    middleware.length < 3 ? noCallbackHandler : withCallbackHandler;\n  return function connectHandler(req, res, next) {\n    return handler(req, res, next, middleware);\n  } as Middleware;\n}\n","import {Middleware, MiddlewareRequest, MiddlewareResponse} from \"./types\"\n\nexport const secureProxyMiddleware: Middleware = function (\n  req: MiddlewareRequest,\n  _res: MiddlewareResponse,\n  next: (error?: Error) => void,\n) {\n  req.protocol = getProtocol(req)\n  next()\n}\n\nfunction getProtocol(req: MiddlewareRequest) {\n  // @ts-ignore\n  // For some reason there is no encrypted on socket while it is expected\n  if (req.connection.encrypted) {\n    return \"https\"\n  }\n  const forwardedProto = req.headers && (req.headers[\"x-forwarded-proto\"] as string)\n  if (forwardedProto) {\n    return forwardedProto.split(/\\s*,\\s*/)[0]\n  }\n  return \"http\"\n}\n","import { IncomingMessage } from 'http';\nimport { NextApiRequest } from 'next';\nexport const isServer = typeof window === 'undefined';\nexport const isClient = typeof window !== 'undefined';\n\nexport function isLocalhost(req: NextApiRequest | IncomingMessage): boolean {\n  let { host } = req.headers;\n  let localhost = false;\n  if (host) {\n    host = host.split(':')[0];\n    localhost = host === 'localhost';\n  }\n  return localhost;\n}\n\nexport function clientDebug(...args: any) {\n  if (typeof window !== 'undefined' && (window as any)['DEBUG_BLITZ']) {\n    console.log('[BLITZ]', ...args);\n  }\n}\n","import cookieSession from 'cookie-session'\nimport passport from 'passport'\nimport { NextApiRequest, NextApiResponse,  } from 'next'\nimport {\n  connectMiddleware,\n  getAllMiddlewareForModule,\n  handleRequestWithMiddleware,\n} from './middleware'\nimport { secureProxyMiddleware } from './secure-proxy-middleware'\nimport { SessionContext } from './supertokens'\nimport { BlitzPassportConfig, Middleware, VerifyCallbackResult,ConnectMiddleware } from './types'\nimport { isLocalhost } from './utils/index'\n\nfunction assert(condition: any, message: string): asserts condition {\n  if (!condition) throw new Error(message)\n}\n\nconst isVerifyCallbackResult = (\n  value: unknown\n): value is VerifyCallbackResult =>\n  typeof value === 'object' && value !== null && 'publicData' in value\n\nconst INTERNAL_REDIRECT_URL_KEY = '_redirectUrl'\n\nexport function passportAuth(config: BlitzPassportConfig) {\n  return async function authHandler(\n    req: NextApiRequest,\n    res: NextApiResponse\n  ) {\n    const cookieSessionMiddleware = cookieSession({\n      secret: process.env.SESSION_SECRET_KEY || 'default-dev-secret',\n      secure: process.env.NODE_ENV === 'production' && !isLocalhost(req),\n    })\n\n    const passportMiddleware = passport.initialize()\n\n    const middleware: Middleware[] = [\n      connectMiddleware(cookieSessionMiddleware as ConnectMiddleware),\n      connectMiddleware(passportMiddleware as ConnectMiddleware),\n      connectMiddleware(passport.session()),\n    ]\n\n    if (config.secureProxy) {\n      middleware.push(secureProxyMiddleware)\n    }\n\n    if (!req.query.auth.length) {\n      return res.status(404).end()\n    }\n\n    assert(\n      config.strategies.length,\n      'No Passport strategies found! Please add at least one strategy.'\n    )\n\n    const blitzStrategy = config.strategies.find(\n      ({ strategy }) => strategy.name === req.query.auth[0]\n    )\n    assert(\n      blitzStrategy,\n      `A passport strategy was not found for: ${req.query.auth[0]}`\n    )\n\n    const { strategy, authenticateOptions } = blitzStrategy\n\n    passport.use(strategy)\n    const strategyName = strategy.name as string\n\n    if (req.query.auth.length === 1) {\n      console.log(`Starting authentication via ${strategyName}...`)\n      if (req.query.redirectUrl) {\n        middleware.push(async (req, res, next) => {\n          const session = res.blitzCtx.session as SessionContext\n          assert(session, 'Missing Blitz sessionMiddleware!')\n          await session.setPublicData({\n            [INTERNAL_REDIRECT_URL_KEY]: req.query.redirectUrl,\n          } as any)\n          return next()\n        })\n      }\n      middleware.push(\n        connectMiddleware(\n          passport.authenticate(strategyName, { ...authenticateOptions })\n        )\n      )\n    } else if (req.query.auth[1] === 'callback') {\n      console.log(`Processing callback for ${strategyName}...`)\n      middleware.push(\n        connectMiddleware((req, res, next) => {\n          const session = (res as any).blitzCtx.session as SessionContext\n          assert(session, 'Missing Blitz sessionMiddleware!')\n\n          passport.authenticate(\n            strategyName,\n            async (err: any, result: unknown) => {\n              try {\n                let error = err\n\n                if (!error) {\n                  if (result === false) {\n                    console.log(\n                      `Login via ${strategyName} failed - usually this means the user did not authenticate properly with the provider`\n                    )\n                    error = `Login failed`\n                  }\n                  assert(\n                    typeof result === 'object' && result !== null,\n                    `Your '${strategyName}' passport verify callback returned empty data. Ensure you call 'done(null, {publicData: {userId: 1, roles: ['myRole']}})')`\n                  )\n                  assert(\n                    (result as any).publicData,\n                    `'publicData' is missing from your '${strategyName}' passport verify callback. Ensure you call 'done(null, {publicData: {userId: 1, roles: ['myRole']}})')`\n                  )\n                }\n\n                const redirectUrlFromVerifyResult =\n                  result &&\n                  typeof result === 'object' &&\n                  (result as any).redirectUrl\n                let redirectUrl: string =\n                  redirectUrlFromVerifyResult ||\n                  (session.publicData as any)[INTERNAL_REDIRECT_URL_KEY] ||\n                  (error\n                    ? config.errorRedirectUrl\n                    : config.successRedirectUrl) ||\n                  '/'\n\n                if (error) {\n                  redirectUrl +=\n                    '?authError=' + encodeURIComponent(error.toString())\n                  res.setHeader('Location', redirectUrl)\n                  res.statusCode = 302\n                  res.end()\n                  return\n                }\n\n                assert(\n                  isVerifyCallbackResult(result),\n                  'Passport verify callback is invalid'\n                )\n\n                delete (result.publicData as any)[INTERNAL_REDIRECT_URL_KEY]\n\n                await session.create(result.publicData, result.privateData)\n\n                res.setHeader('Location', redirectUrl)\n                res.statusCode = 302\n                res.end()\n              } catch (error) {\n                console.error(error)\n                res.statusCode = 500\n                res.end()\n              }\n            }\n          )(req, res, next)\n        })\n      )\n    }\n\n    const globalMiddleware = getAllMiddlewareForModule({} as any)\n    await handleRequestWithMiddleware(req, res, [\n      ...globalMiddleware,\n      ...middleware,\n    ])\n  }\n}\n","// regarding tokens\nexport const TOKEN_SEPARATOR = \";\"\nexport const HANDLE_SEPARATOR = \":\"\nexport const SESSION_TYPE_OPAQUE_TOKEN_SIMPLE = \"ots\"\nexport const SESSION_TYPE_ANONYMOUS_JWT = \"ajwt\"\nexport const SESSION_TOKEN_VERSION_0 = \"v0\"\n\nexport const COOKIE_ANONYMOUS_SESSION_TOKEN = \"sAnonymousSessionToken\"\nexport const COOKIE_SESSION_TOKEN = \"sSessionToken\"\nexport const COOKIE_REFRESH_TOKEN = \"sIdRefreshToken\"\nexport const COOKIE_CSRF_TOKEN = \"sAntiCrfToken\"\nexport const COOKIE_PUBLIC_DATA_TOKEN = \"sPublicDataToken\"\n\n// Headers always all lower case\nexport const HEADER_CSRF = \"anti-csrf\"\nexport const HEADER_PUBLIC_DATA_TOKEN = \"public-data-token\"\nexport const HEADER_SESSION_REVOKED = \"session-revoked\"\nexport const HEADER_CSRF_ERROR = \"csrf-error\"\n\nexport const LOCALSTORAGE_PREFIX = \"_blitz-\"\n","import { fromBase64, toBase64 } from 'b64-lite';\nimport cookie from 'cookie';\nimport { addMinutes, addYears, differenceInMinutes, isPast } from 'date-fns';\nimport { IncomingMessage, ServerResponse } from 'http';\nimport { sign as jwtSign, verify as jwtVerify } from 'jsonwebtoken';\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { getCookieParser } from 'next/dist/next-server/server/api-utils';\nimport { generateToken, hash256 } from './auth-utils';\nimport {\n  COOKIE_ANONYMOUS_SESSION_TOKEN,\n  COOKIE_CSRF_TOKEN,\n  COOKIE_PUBLIC_DATA_TOKEN,\n  COOKIE_REFRESH_TOKEN,\n  COOKIE_SESSION_TOKEN,\n  HANDLE_SEPARATOR,\n  HEADER_CSRF,\n  HEADER_CSRF_ERROR,\n  HEADER_PUBLIC_DATA_TOKEN,\n  HEADER_SESSION_REVOKED,\n  SESSION_TOKEN_VERSION_0,\n  SESSION_TYPE_ANONYMOUS_JWT,\n  SESSION_TYPE_OPAQUE_TOKEN_SIMPLE,\n  TOKEN_SEPARATOR,\n} from './constants';\nimport {\n  AuthenticationError,\n  AuthorizationError,\n  CSRFTokenMismatchError,\n} from './errors';\nimport { SessionConfig, SessionContext } from './supertokens';\nimport { MiddlewareResponse, PublicData } from './types';\nimport { isLocalhost } from './utils';\n\ntype JwtPayload = AnonymousSessionPayload | null;\ntype AnonSessionKernel = {\n  handle: string;\n  publicData: PublicData;\n  jwtPayload: JwtPayload;\n  antiCSRFToken: string;\n  anonymousSessionToken: string;\n};\ntype AuthedSessionKernel = {\n  handle: string;\n  publicData: PublicData;\n  jwtPayload: JwtPayload;\n  antiCSRFToken: string;\n  sessionToken: string;\n};\ntype SessionKernel = AnonSessionKernel | AuthedSessionKernel;\n\nfunction assert(condition: any, message: string): asserts condition {\n  if (!condition) throw new Error(message);\n}\n\nconst defaultConfig = (prisma: any): SessionConfig => ({\n  sessionExpiryMinutes: 30 * 24 * 60, // Sessions expire after 30 days of being idle\n  method: 'essential',\n  sameSite: 'lax',\n  getSession: (handle) => prisma.session.findFirst({ where: { handle } }),\n  getSessions: (userId) => prisma.session.findMany({ where: { userId } }),\n  createSession: (session) => {\n    let user;\n    if (session.userId) {\n      user = { connect: { id: session.userId } };\n    }\n    return prisma.session.create({\n      data: { ...session, userId: undefined, user },\n    });\n  },\n  updateSession: async (handle, session) => {\n    try {\n      return await prisma.session.update({ where: { handle }, data: session });\n    } catch (error) {\n      // Session doesn't exist in DB for some reason, so create it\n      if (error.code === 'P2016') {\n        console.log(\"Could not update session because it's not in the DB\");\n      } else {\n        throw error;\n      }\n    }\n  },\n  deleteSession: (handle) => prisma.session.delete({ where: { handle } }),\n  isAuthorized: () => {\n    throw new Error('No isAuthorized implementation provided');\n  },\n});\n\nconst isNextApiRequest = (\n  req: NextApiRequest | IncomingMessage\n): req is NextApiRequest => 'cookies' in req;\nconst isMiddlewareApResponse = (\n  res: MiddlewareResponse | ServerResponse\n): res is MiddlewareResponse => 'blitzCtx' in res;\n\nexport async function getSessionContext(\n  prisma: any,\n  req: NextApiRequest | IncomingMessage,\n  res: NextApiResponse | ServerResponse\n): Promise<SessionContext> {\n  const config = defaultConfig(prisma);\n\n  if (!('cookies' in req)) {\n    // Cookie parser isn't include inside getServerSideProps, so we have to add it\n    (req as NextApiRequest).cookies = getCookieParser(req)();\n  }\n  assert(\n    isNextApiRequest(req),\n    \"[getSessionContext]: Request type isn't NextApiRequest\"\n  );\n\n  if (isMiddlewareApResponse(res) && res.blitzCtx.session) {\n    return res.blitzCtx.session as SessionContext;\n  }\n\n  let sessionKernel = await getSession(config, req, res);\n\n  if (sessionKernel) {\n    console.log('Got existing session', sessionKernel);\n  }\n\n  if (!sessionKernel) {\n    console.log('No session found, creating anonymous session');\n    sessionKernel = await createAnonymousSession(config, req, res);\n  }\n\n  const sessionContext = new SessionContextClass(\n    config,\n    req,\n    res,\n    sessionKernel\n  );\n  if (!('blitzCtx' in res)) {\n    (res as MiddlewareResponse).blitzCtx = {};\n  }\n  (res as MiddlewareResponse).blitzCtx.session = sessionContext;\n  return sessionContext;\n}\n\nexport class SessionContextClass implements SessionContext {\n  private config: SessionConfig;\n  private _req: IncomingMessage;\n  private _res: ServerResponse;\n  private _kernel: SessionKernel;\n\n  constructor(\n    config: SessionConfig,\n    req: IncomingMessage,\n    res: ServerResponse,\n    kernel: SessionKernel\n  ) {\n    this.config = config;\n    this._req = req;\n    this._res = res;\n    this._kernel = kernel;\n  }\n\n  get handle() {\n    return this._kernel.handle;\n  }\n  get userId() {\n    return this._kernel.publicData.userId;\n  }\n  get roles() {\n    return this._kernel.publicData.roles;\n  }\n  get publicData() {\n    return this._kernel.publicData;\n  }\n\n  authorize(input?: any) {\n    const e = new AuthenticationError();\n    Error.captureStackTrace(e, this.authorize);\n    if (!this.userId) throw e;\n\n    if (!this.isAuthorized(input)) {\n      const e = new AuthorizationError();\n      Error.captureStackTrace(e, this.authorize);\n      throw e;\n    }\n  }\n\n  isAuthorized(input?: any) {\n    if (!this.userId) return false;\n\n    return this.config.isAuthorized(this.roles, input);\n  }\n\n  async create(publicData: PublicData, privateData?: Record<any, any>) {\n    this._kernel = await createNewSession(\n      this.config,\n      this._req,\n      this._res,\n      publicData,\n      privateData,\n      {\n        jwtPayload: this._kernel.jwtPayload,\n      }\n    );\n  }\n\n  revoke() {\n    return revokeSession(this.config, this._req, this._res, this.handle);\n  }\n\n  async revokeAll() {\n    if (!this.publicData.userId) {\n      throw new Error(\n        'session.revokeAll() cannot be used with anonymous sessions'\n      );\n    }\n    await revokeAllSessionsForUser(\n      this.config,\n      this._req,\n      this._res,\n      this.publicData.userId\n    );\n    return;\n  }\n\n  async setPublicData(data: Record<any, any>) {\n    if (this.userId && data.roles) {\n      await updateAllPublicDataRolesForUser(\n        this.config,\n        this.userId,\n        data.roles\n      );\n    }\n    this._kernel.publicData = await setPublicData(\n      this.config,\n      this._req,\n      this._res,\n      this._kernel,\n      data\n    );\n  }\n\n  async getPrivateData() {\n    return (await getPrivateData(this.config, this.handle)) || {};\n  }\n  setPrivateData(data: Record<any, any>) {\n    return setPrivateData(this.config, this._kernel, data);\n  }\n}\n\n// --------------------------------\n// Token/handle utils\n// --------------------------------\nconst TOKEN_LENGTH = 32;\n\nexport const generateEssentialSessionHandle = () => {\n  return (\n    generateToken(TOKEN_LENGTH) +\n    HANDLE_SEPARATOR +\n    SESSION_TYPE_OPAQUE_TOKEN_SIMPLE\n  );\n};\n\nexport const generateAnonymousSessionHandle = () => {\n  return (\n    generateToken(TOKEN_LENGTH) + HANDLE_SEPARATOR + SESSION_TYPE_ANONYMOUS_JWT\n  );\n};\n\nexport const createSessionToken = (\n  handle: string,\n  publicData: PublicData | string\n) => {\n  // We store the hashed public data in the opaque token so that when we verify,\n  // we can detect changes in it and return a new set of tokens if necessary.\n\n  let publicDataString;\n  if (typeof publicData === 'string') {\n    publicDataString = publicData;\n  } else {\n    publicDataString = JSON.stringify(publicData);\n  }\n  return toBase64(\n    [\n      handle,\n      generateToken(TOKEN_LENGTH),\n      hash256(publicDataString),\n      SESSION_TOKEN_VERSION_0,\n    ].join(TOKEN_SEPARATOR)\n  );\n};\nexport const parseSessionToken = (token: string) => {\n  const [handle, id, hashedPublicData, version] = fromBase64(token).split(\n    TOKEN_SEPARATOR\n  );\n\n  if (!handle || !id || !hashedPublicData || !version) {\n    throw new AuthenticationError('Failed to parse session token');\n  }\n\n  return {\n    handle,\n    id,\n    hashedPublicData,\n    version,\n  };\n};\n\nexport const createPublicDataToken = (publicData: string | PublicData) => {\n  const payload =\n    typeof publicData === 'string' ? publicData : JSON.stringify(publicData);\n  return toBase64(payload);\n};\n\nexport const createAntiCSRFToken = () => generateToken(TOKEN_LENGTH);\n\nexport type AnonymousSessionPayload = {\n  isAnonymous: true;\n  handle: string;\n  publicData: PublicData;\n  antiCSRFToken: string;\n};\n\nexport const getSessionSecretKey = () => {\n  if (process.env.NODE_ENV === 'production') {\n    assert(\n      process.env.SESSION_SECRET_KEY,\n      'You must provide the SESSION_SECRET_KEY environment variable in production. This used to sign and verify tokens. It should be 32 chars long.'\n    );\n    assert(\n      process.env.SESSION_SECRET_KEY.length >= 32,\n      'The SESSION_SECRET_KEY environment variable must be at least 32 bytes for sufficent token security'\n    );\n\n    return process.env.SESSION_SECRET_KEY;\n  } else {\n    return process.env.SESSION_SECRET_KEY || 'default-dev-secret';\n  }\n};\n\nconst JWT_NAMESPACE = 'blitzjs';\nconst JWT_ISSUER = 'blitzjs';\nconst JWT_AUDIENCE = 'blitzjs';\nconst JWT_ANONYMOUS_SUBJECT = 'anonymous';\nconst JWT_ALGORITHM = 'HS256';\n\nexport const createAnonymousSessionToken = (\n  payload: AnonymousSessionPayload\n) => {\n  return jwtSign({ [JWT_NAMESPACE]: payload }, getSessionSecretKey(), {\n    algorithm: JWT_ALGORITHM,\n    issuer: JWT_ISSUER,\n    audience: JWT_AUDIENCE,\n    subject: JWT_ANONYMOUS_SUBJECT,\n  });\n};\n\nexport const parseAnonymousSessionToken = (token: string) => {\n  // This must happen outside the try/catch because it could throw an error\n  // about a missing environment variable\n  const secret = getSessionSecretKey();\n\n  try {\n    const fullPayload = jwtVerify(token, secret, {\n      algorithms: [JWT_ALGORITHM],\n      issuer: JWT_ISSUER,\n      audience: JWT_AUDIENCE,\n      subject: JWT_ANONYMOUS_SUBJECT,\n    });\n\n    if (typeof fullPayload === 'object') {\n      return (fullPayload as any)[JWT_NAMESPACE] as AnonymousSessionPayload;\n    } else {\n      return null;\n    }\n  } catch (error) {\n    return null;\n  }\n};\n\nexport const setCookie = (res: ServerResponse, cookie: string) => {\n  append(res, 'Set-Cookie', cookie);\n};\n\nexport const setHeader = (res: ServerResponse, name: string, value: string) => {\n  res.setHeader(name, value);\n  if ('_blitz' in res) {\n    (res as any)._blitz[name] = value;\n  }\n};\n\nexport const removeHeader = (res: ServerResponse, name: string) => {\n  res.removeHeader(name);\n  if ('_blitz' in res) {\n    delete (res as any)._blitz[name];\n  }\n};\n\nexport const setSessionCookie = (\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  sessionToken: string,\n  expiresAt: Date\n) => {\n  setCookie(\n    res,\n    cookie.serialize(COOKIE_SESSION_TOKEN, sessionToken, {\n      path: '/',\n      httpOnly: true,\n      secure:\n        !process.env.DISABLE_SECURE_COOKIES &&\n        process.env.NODE_ENV === 'production' &&\n        !isLocalhost(req),\n      sameSite: config.sameSite,\n      domain: config.domain,\n      expires: expiresAt,\n    })\n  );\n};\n\nexport const setAnonymousSessionCookie = (\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  token: string,\n  expiresAt: Date\n) => {\n  setCookie(\n    res,\n    cookie.serialize(COOKIE_ANONYMOUS_SESSION_TOKEN, token, {\n      path: '/',\n      httpOnly: true,\n      secure:\n        !process.env.DISABLE_SECURE_COOKIES &&\n        process.env.NODE_ENV === 'production' &&\n        !isLocalhost(req),\n      sameSite: config.sameSite,\n      domain: config.domain,\n      expires: expiresAt,\n    })\n  );\n};\n\nexport const setCSRFCookie = (\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  antiCSRFToken: string,\n  expiresAt: Date\n) => {\n  console.log('setCSRFCookie', antiCSRFToken);\n  setCookie(\n    res,\n    cookie.serialize(COOKIE_CSRF_TOKEN, antiCSRFToken, {\n      path: '/',\n      secure:\n        !process.env.DISABLE_SECURE_COOKIES &&\n        process.env.NODE_ENV === 'production' &&\n        !isLocalhost(req),\n      sameSite: config.sameSite,\n      domain: config.domain,\n      expires: expiresAt,\n    })\n  );\n};\n\nexport const setPublicDataCookie = (\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  publicDataToken: string,\n  expiresAt: Date\n) => {\n  setHeader(res, HEADER_PUBLIC_DATA_TOKEN, 'updated');\n  setCookie(\n    res,\n    cookie.serialize(COOKIE_PUBLIC_DATA_TOKEN, publicDataToken, {\n      path: '/',\n      secure:\n        !process.env.DISABLE_SECURE_COOKIES &&\n        process.env.NODE_ENV === 'production' &&\n        !isLocalhost(req),\n      sameSite: config.sameSite,\n      domain: config.domain,\n      expires: expiresAt,\n    })\n  );\n};\n\n// --------------------------------\n// Get Session\n// --------------------------------\nexport async function getSession(\n  config: SessionConfig,\n  req: NextApiRequest,\n  res: ServerResponse\n): Promise<SessionKernel | null> {\n  const anonymousSessionToken = req.cookies[COOKIE_ANONYMOUS_SESSION_TOKEN];\n  const sessionToken = req.cookies[COOKIE_SESSION_TOKEN]; // for essential method\n  const idRefreshToken = req.cookies[COOKIE_REFRESH_TOKEN]; // for advanced method\n  const enableCsrfProtection =\n    req.method !== 'GET' &&\n    req.method !== 'OPTIONS' &&\n    !process.env.DISABLE_CSRF_PROTECTION;\n  const antiCSRFToken = req.headers[HEADER_CSRF] as string;\n\n  if (sessionToken) {\n    console.log('[getSession] Request has sessionToken');\n    const { handle, version, hashedPublicData } = parseSessionToken(\n      sessionToken\n    );\n\n    if (!handle) {\n      console.log('No handle in sessionToken');\n      return null;\n    }\n\n    if (version !== SESSION_TOKEN_VERSION_0) {\n      console.log(\n        new AuthenticationError(\n          'Session token version is not ' + SESSION_TOKEN_VERSION_0\n        )\n      );\n      return null;\n    }\n\n    const persistedSession = await config.getSession(handle);\n    if (!persistedSession) {\n      console.log('Session not found in DB');\n      return null;\n    }\n    if (persistedSession.hashedSessionToken !== hash256(sessionToken)) {\n      console.log('sessionToken hash did not match');\n      console.log('persisted: ', persistedSession.hashedSessionToken);\n      console.log('in req: ', hash256(sessionToken));\n      return null;\n    }\n    if (persistedSession.expiresAt && isPast(persistedSession.expiresAt)) {\n      console.log('Session expired');\n      return null;\n    }\n    if (\n      enableCsrfProtection &&\n      persistedSession.antiCSRFToken !== antiCSRFToken\n    ) {\n      // await revokeSession(req, res, handle)\n      setHeader(res, HEADER_CSRF_ERROR, 'true');\n      throw new CSRFTokenMismatchError();\n    }\n\n    /*\n     * Session Renewal - Will renew if any of the following is true\n     * 1) publicData has changed\n     * 2) 1/4 of expiry time has elasped\n     *\n     *  But only renew with non-GET requests because a GET request could be from a\n     *  browser level navigation\n     */\n    if (req.method !== 'GET') {\n      // The publicData in the DB could have been updated since this client last made\n      // a request. If so, then we generate a new access token\n      const hasPublicDataChanged =\n        hash256(persistedSession.publicData) !== hashedPublicData;\n      if (hasPublicDataChanged) {\n        console.log('PublicData has changed since the last request');\n      }\n\n      // Check if > 1/4th of the expiry time has passed\n      // (since we are doing a rolling expiry window).\n      const hasQuarterExpiryTimePassed =\n        persistedSession.expiresAt &&\n        differenceInMinutes(persistedSession.expiresAt, new Date()) <\n          0.75 * config.sessionExpiryMinutes;\n\n      if (hasQuarterExpiryTimePassed) {\n        console.log('quarter expiry time has passed');\n        console.log('Persisted expire time', persistedSession.expiresAt);\n      }\n\n      if (hasPublicDataChanged || hasQuarterExpiryTimePassed) {\n        await refreshSession(\n          config,\n          req,\n          res,\n          {\n            handle,\n            publicData: JSON.parse(persistedSession.publicData || ''),\n            jwtPayload: null,\n            antiCSRFToken,\n            sessionToken,\n          },\n          { publicDataChanged: hasPublicDataChanged }\n        );\n      }\n    }\n\n    return {\n      handle,\n      publicData: JSON.parse(persistedSession.publicData || ''),\n      jwtPayload: null,\n      antiCSRFToken,\n      sessionToken,\n    };\n  } else if (idRefreshToken) {\n    // TODO: advanced method\n    return null;\n    // Important: check anonymousSessionToken token as the very last thing\n  } else if (anonymousSessionToken) {\n    console.log('Request has anonymousSessionToken');\n    const payload = parseAnonymousSessionToken(anonymousSessionToken);\n\n    if (!payload) {\n      console.log('Payload empty');\n      return null;\n    }\n\n    if (enableCsrfProtection && payload.antiCSRFToken !== antiCSRFToken) {\n      // await revokeSession(req, res, payload.handle, true)\n      setHeader(res, HEADER_CSRF_ERROR, 'true');\n      throw new CSRFTokenMismatchError();\n    }\n\n    return {\n      handle: payload.handle,\n      publicData: payload.publicData,\n      jwtPayload: payload,\n      antiCSRFToken,\n      anonymousSessionToken,\n    };\n  }\n\n  // No session exists\n  return null;\n}\n\n// --------------------------------\n// Create Session\n// --------------------------------\nexport async function createNewSession(\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  publicData: PublicData,\n  privateData: Record<any, any> = {},\n  opts: { anonymous?: boolean; jwtPayload?: JwtPayload } = {}\n): Promise<SessionKernel> {\n  assert(publicData.userId !== undefined, 'You must provide publicData.userId');\n  assert(publicData.roles, 'You must provide publicData.roles');\n\n  const antiCSRFToken = createAntiCSRFToken();\n\n  if (opts.anonymous) {\n    console.log('Creating new anonymous session');\n    const handle = generateAnonymousSessionHandle();\n    const payload: AnonymousSessionPayload = {\n      isAnonymous: true,\n      handle,\n      publicData,\n      antiCSRFToken,\n    };\n    const anonymousSessionToken = createAnonymousSessionToken(payload);\n    const publicDataToken = createPublicDataToken(publicData);\n\n    const expiresAt = addYears(new Date(), 30);\n    setAnonymousSessionCookie(\n      config,\n      req,\n      res,\n      anonymousSessionToken,\n      expiresAt\n    );\n    setCSRFCookie(config, req, res, antiCSRFToken, expiresAt);\n    setPublicDataCookie(config, req, res, publicDataToken, expiresAt);\n    // Clear the essential session cookie in case it was previously set\n    setSessionCookie(config, req, res, '', new Date(0));\n\n    return {\n      handle,\n      publicData,\n      jwtPayload: payload,\n      antiCSRFToken,\n      anonymousSessionToken,\n    };\n  } else if (config.method === 'essential') {\n    console.log('Creating new session');\n    const newPublicData: PublicData = {\n      // This carries over any public data from the anonymous session\n      ...(opts.jwtPayload?.publicData || {}),\n      ...publicData,\n    };\n    assert(\n      newPublicData.userId,\n      'You must provide a non-empty userId as publicData.userId'\n    );\n\n    // This carries over any private data from the anonymous session\n    let existingPrivateData = {};\n    if (opts.jwtPayload?.isAnonymous) {\n      const session = await config.getSession(opts.jwtPayload.handle);\n      if (session) {\n        if (session.privateData) {\n          existingPrivateData = JSON.parse(session.privateData);\n        }\n        // Delete the previous anonymous session\n        await config.deleteSession(opts.jwtPayload.handle);\n      }\n    }\n\n    const newPrivateData: Record<any, any> = {\n      ...existingPrivateData,\n      ...privateData,\n    };\n\n    const expiresAt = addMinutes(new Date(), config.sessionExpiryMinutes);\n    const handle = generateEssentialSessionHandle();\n    const sessionToken = createSessionToken(handle, newPublicData);\n    const publicDataToken = createPublicDataToken(newPublicData);\n\n    await config.createSession({\n      expiresAt,\n      handle,\n      userId: newPublicData.userId,\n      hashedSessionToken: hash256(sessionToken),\n      antiCSRFToken,\n      publicData: JSON.stringify(newPublicData),\n      privateData: JSON.stringify(newPrivateData),\n    });\n\n    setSessionCookie(config, req, res, sessionToken, expiresAt);\n    setCSRFCookie(config, req, res, antiCSRFToken, expiresAt);\n    setPublicDataCookie(config, req, res, publicDataToken, expiresAt);\n    // Clear the anonymous session cookie in case it was previously set\n    setAnonymousSessionCookie(config, req, res, '', new Date(0));\n    removeHeader(res, HEADER_SESSION_REVOKED);\n\n    return {\n      handle,\n      publicData: newPublicData,\n      jwtPayload: null,\n      antiCSRFToken,\n      sessionToken,\n    };\n  } else if (config.method === 'advanced') {\n    throw new Error('The advanced method is not yet supported');\n  } else {\n    throw new Error(\n      `Session management method ${config.method} is invalid. Supported methods are \"essential\" and \"advanced\"`\n    );\n  }\n}\n\nexport async function createAnonymousSession(\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse\n) {\n  return await createNewSession(\n    config,\n    req,\n    res,\n    { userId: null, roles: [] },\n    undefined,\n    { anonymous: true }\n  );\n}\n\n// --------------------------------\n// Session/DB utils\n// --------------------------------\n\nexport async function refreshSession(\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  sessionKernel: SessionKernel,\n  { publicDataChanged }: { publicDataChanged: boolean }\n) {\n  console.log('Refreshing session', sessionKernel);\n  if (sessionKernel.jwtPayload?.isAnonymous) {\n    const payload: AnonymousSessionPayload = {\n      ...sessionKernel.jwtPayload,\n      publicData: sessionKernel.publicData,\n    };\n    const anonymousSessionToken = createAnonymousSessionToken(payload);\n    const publicDataToken = createPublicDataToken(sessionKernel.publicData);\n\n    const expiresAt = addYears(new Date(), 30);\n    setAnonymousSessionCookie(\n      config,\n      req,\n      res,\n      anonymousSessionToken,\n      expiresAt\n    );\n    setPublicDataCookie(config, req, res, publicDataToken, expiresAt);\n    setCSRFCookie(config, req, res, sessionKernel.antiCSRFToken, expiresAt);\n  } else if (config.method === 'essential' && 'sessionToken' in sessionKernel) {\n    const expiresAt = addMinutes(new Date(), config.sessionExpiryMinutes);\n    const publicDataToken = createPublicDataToken(sessionKernel.publicData);\n\n    let sessionToken: string;\n    // Only generate new session token if public data actually changed\n    // Otherwise if new session token is generated just for refresh, then\n    // we have race condition bugs\n    if (publicDataChanged) {\n      sessionToken = createSessionToken(\n        sessionKernel.handle,\n        sessionKernel.publicData\n      );\n    } else {\n      sessionToken = sessionKernel.sessionToken;\n    }\n\n    setSessionCookie(config, req, res, sessionToken, expiresAt);\n    setPublicDataCookie(config, req, res, publicDataToken, expiresAt);\n    setCSRFCookie(config, req, res, sessionKernel.antiCSRFToken, expiresAt);\n\n    console.log('Updating session in db with', { expiresAt });\n    if (publicDataChanged) {\n      await config.updateSession(sessionKernel.handle, {\n        expiresAt,\n        hashedSessionToken: hash256(sessionToken),\n        publicData: JSON.stringify(sessionKernel.publicData),\n      });\n    } else {\n      await config.updateSession(sessionKernel.handle, { expiresAt });\n    }\n  } else if (config.method === 'advanced') {\n    throw new Error('refreshSession() not implemented for advanced method');\n  }\n}\n\nexport async function getAllSessionHandlesForUser(\n  config: SessionConfig,\n  userId: string\n) {\n  return (await config.getSessions(userId)).map((session) => session.handle);\n}\n\nexport async function updateAllPublicDataRolesForUser(\n  config: SessionConfig,\n  userId: string | number,\n  roles: string[]\n) {\n  const sessions = await config.getSessions(userId);\n\n  for (const session of sessions) {\n    const publicData = JSON.stringify({\n      ...(session.publicData ? JSON.parse(session.publicData) : {}),\n      roles,\n    });\n    await config.updateSession(session.handle, { publicData });\n  }\n}\n\nexport async function revokeSession(\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  handle: string,\n  anonymous: boolean = false\n): Promise<void> {\n  console.log('Revoking session', handle);\n  if (!anonymous) {\n    try {\n      await config.deleteSession(handle);\n    } catch (error) {\n      // Ignore any errors, like if session doesn't exist in DB\n    }\n  }\n  // This is used on the frontend to clear localstorage\n  setHeader(res, HEADER_SESSION_REVOKED, 'true');\n\n  // Clear all cookies\n  setSessionCookie(config, req, res, '', new Date(0));\n  setAnonymousSessionCookie(config, req, res, '', new Date(0));\n  setCSRFCookie(config, req, res, '', new Date(0));\n}\n\nexport async function revokeMultipleSessions(\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  sessionHandles: string[]\n) {\n  let revoked: string[] = [];\n  for (const handle of sessionHandles) {\n    await revokeSession(config, req, res, handle);\n    revoked.push(handle);\n  }\n  return revoked;\n}\n\nexport async function revokeAllSessionsForUser(\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  userId: string | number\n) {\n  let sessionHandles = (await config.getSessions(userId)).map(\n    (session) => session.handle\n  );\n  return revokeMultipleSessions(config, req, res, sessionHandles);\n}\n\nexport async function getPublicData(\n  config: SessionConfig,\n  sessionKernel: SessionKernel\n): Promise<PublicData> {\n  if (sessionKernel.jwtPayload?.publicData) {\n    return sessionKernel.jwtPayload?.publicData;\n  } else {\n    const session = await config.getSession(sessionKernel.handle);\n    if (!session) {\n      throw new Error(\n        \"getPublicData() failed because handle doesn't exist \" +\n          sessionKernel.handle\n      );\n    }\n    if (session.publicData) {\n      return JSON.parse(session.publicData) as PublicData;\n    } else {\n      return {} as PublicData;\n    }\n  }\n}\n\nexport async function getPrivateData(\n  config: SessionConfig,\n  handle: string\n): Promise<Record<any, any> | null> {\n  const session = await config.getSession(handle);\n  if (session && session.privateData) {\n    return JSON.parse(session.privateData) as Record<any, any>;\n  } else {\n    return null;\n  }\n}\n\nexport async function setPrivateData(\n  config: SessionConfig,\n  sessionKernel: SessionKernel,\n  data: Record<any, any>\n) {\n  let existingPrivateData = await getPrivateData(config, sessionKernel.handle);\n  if (existingPrivateData === null) {\n    // Anonymous sessions may not exist in the DB yet\n    try {\n      await config.createSession({ handle: sessionKernel.handle });\n    } catch (error) {}\n    existingPrivateData = {};\n  }\n  const privateData = JSON.stringify({\n    ...existingPrivateData,\n    ...data,\n  });\n  await config.updateSession(sessionKernel.handle, { privateData });\n}\n\nexport async function setPublicData(\n  config: SessionConfig,\n  req: IncomingMessage,\n  res: ServerResponse,\n  sessionKernel: SessionKernel,\n  data: Record<any, any>\n) {\n  // Don't allow updating userId\n  delete data.userId;\n\n  const publicData: PublicData = {\n    ...(await getPublicData(config, sessionKernel)),\n    ...data,\n  };\n\n  await refreshSession(\n    config,\n    req,\n    res,\n    { ...sessionKernel, publicData },\n    { publicDataChanged: true }\n  );\n  return publicData;\n}\n\n/**\n * Append additional header `field` with value `val`.\n *\n * Example:\n *\n *    append(res, 'Set-Cookie', 'foo=bar; Path=/; HttpOnly');\n *\n * @param {ServerResponse} res\n * @param {string} field\n * @param {string| string[]} val\n */\nexport function append(\n  res: ServerResponse,\n  field: string,\n  val: string | string[]\n) {\n  let prev: string | string[] | undefined = res.getHeader(field) as\n    | string\n    | string[]\n    | undefined;\n  let value = val;\n\n  if (prev !== undefined) {\n    // concat the new and prev vals\n    value = Array.isArray(prev)\n      ? prev.concat(val)\n      : Array.isArray(val)\n      ? [prev].concat(val)\n      : [prev, val];\n  }\n\n  value = Array.isArray(value) ? value.map(String) : String(value);\n\n  res.setHeader(field, value);\n  return res;\n}\n"],"names":["runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","AuthenticationError","message","CSRFTokenMismatchError","AuthorizationError","hash256","input","crypto","update","digest","generateToken","numberOfCharacters","nanoid","SP","SecurePasswordLib","SecurePassword","hash","password","Buffer","from","verify","hashedPassword","VALID","VALID_NEEDS_REHASH","hashPassword","verifyPassword","console","authenticateUser","prisma","email","user","findFirst","where","toLowerCase","improvedHash","id","data","rest","getAllMiddlewareForModule","resolverModule","middleware","Array","isArray","_meta","handleRequestWithMiddleware","req","res","throwOnError","stackPrintOnError","blitzCtx","_blitz","handler","compose","log","writableFinished","statusCode","_context","status","end","_clearStack","stack","index","dispatch","bind","noCallbackHandler","withCallbackHandler","connectMiddleware","secureProxyMiddleware","_res","protocol","connection","encrypted","forwardedProto","headers","split","getProtocol","isLocalhost","host","localhost","assert","condition","SESSION_TOKEN_VERSION_0","defaultConfig","sessionExpiryMinutes","sameSite","getSession","session","getSessions","userId","findMany","createSession","connect","updateSession","code","deleteSession","isAuthorized","isNextApiRequest","isMiddlewareApResponse","config","cookies","getCookieParser","sessionKernel","createAnonymousSession","sessionContext","SessionContextClass","kernel","_req","_kernel","authorize","e","captureStackTrace","roles","publicData","privateData","createNewSession","jwtPayload","revoke","revokeSession","revokeAll","revokeAllSessionsForUser","setPublicData","updateAllPublicDataRolesForUser","getPrivateData","setPrivateData","generateEssentialSessionHandle","generateAnonymousSessionHandle","createSessionToken","publicDataString","JSON","stringify","toBase64","join","parseSessionToken","token","fromBase64","hashedPublicData","version","createPublicDataToken","payload","createAntiCSRFToken","getSessionSecretKey","process","env","SESSION_SECRET_KEY","createAnonymousSessionToken","jwtSign","algorithm","issuer","audience","subject","parseAnonymousSessionToken","secret","fullPayload","jwtVerify","algorithms","setCookie","cookie","field","val","getHeader","concat","map","String","setHeader","append","removeHeader","setSessionCookie","sessionToken","expiresAt","serialize","path","httpOnly","secure","DISABLE_SECURE_COOKIES","domain","expires","setAnonymousSessionCookie","setCSRFCookie","antiCSRFToken","setPublicDataCookie","publicDataToken","anonymousSessionToken","idRefreshToken","enableCsrfProtection","DISABLE_CSRF_PROTECTION","persistedSession","hashedSessionToken","isPast","hasPublicDataChanged","hasQuarterExpiryTimePassed","differenceInMinutes","Date","refreshSession","parse","publicDataChanged","opts","anonymous","isAnonymous","addYears","newPublicData","existingPrivateData","_opts$jwtPayload2","newPrivateData","addMinutes","_sessionKernel$jwtPay","revokeMultipleSessions","sessionHandles","revoked","getPublicData","_sessionKernel$jwtPay2","_sessionKernel$jwtPay3","cookieSessionMiddleware","cookieSession","passportMiddleware","passport","initialize","secureProxy","query","auth","strategies","blitzStrategy","find","strategy","authenticateOptions","use","strategyName","redirectUrl","authenticate","errorRedirectUrl","successRedirectUrl","encodeURIComponent","globalMiddleware"],"mappings":"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"}